import 'dart:async';
import 'dart:convert';
import 'dart:io';

//Dart is Single-threaded Programming language
main(List<String> args) async {
  //loadString("Hello From Dart").then((s) => print(s));

  // addAsync(50).then((x) => x(50)).then((y) => print(y));
  //or
  Function x = await addAsync(50);
  int z = await x(40);
  //print(z);

  //-------------Stream-------------
  // Stream provided us with a way of accessing asynchronous
  // Sequences of data its sort of like an asynchronous Iterator.
  // So these Sequences can be user generated events or they can be
  // that are generated by apis or maybe reading from files and
  // thing like that and there are various different ways that we
  // can actually unwrap stream inside of dart. we have a construct called
  // the await for loop and also have listners.Also have a built in way of deal
  // with error and deal with when they actually finish executing and there are
  // two main types of stream inside of dart. We have single subscription and
  // broadcrast stream

  Stream stream = exampleStream(20);
  await for (var s in stream) {
    print("Number : $s");
  }
  //or
  exampleStream(2).listen((int x) => print("Number :$x"));

  AnotherStremRealWorldExmp();
}

//Future is a means of getting a value or piece of data sometime in the future
//So its basically like creating a promise in the code that says ok well
//well eventually we will get a string
Future<String> loadString(String str) {
  return Future.delayed(Duration(seconds: 10)).then((_) {
    return "String: $str";
  });
}

Future<Function> addAsync(int x) async {
  return (int y) async => x + y;
}

Stream<int> exampleStream(int x) async* {
  for (var i = 0; i < x; i++) {
    yield i;
  }
}

AnotherStremRealWorldExmp() async {
  File file = new File("text.txt");
  IOSink sink = file.openWrite(mode: FileMode.APPEND);
  sink.add(
      utf8.encode("Hello form dart at ${DateTime.now().toIso8601String()}"));

  await sink.flush();
  await sink.close();

  Stream<List<int>> stream = file.openRead().asBroadcastStream();
  stream.transform(utf8.decoder).transform(LineSplitter()).listen(
        (String line) => print(line),
        onDone: () => print("Stream Closed"),
        onError: (e) => print(e.toString()),
      );

  stream.listen((byte) => print(byte.toList()));
}
